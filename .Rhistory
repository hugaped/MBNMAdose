checkmate::assertDataFrame(data)
treatments <- factor(unique(data$treatment))
data <- data %>%
dplyr::group_by(studyID) %>%
dplyr::mutate(design=list(as.numeric(treatment)))
comparisons <- ref.comparisons(data)
splits1 <- vector()
splits2 <- vector()
paths <- vector()
loops <- vector()
pb <- txtProgressBar(0, nrow(comparisons), style = 3)
for (i in 1:nrow(comparisons)) {
setTxtProgressBar(i, mcmc)
drops <- comparisons[-i,]
# Alternative graph create (non-gemtc)
g <- igraph::graph.empty()
g <- g + igraph::vertex(levels(treatments))
#g <- g + igraph::edges.create(new.comparisons, arrow.mode=0)
ed <- t(matrix(c(drops[["t1"]], drops[["t2"]]), ncol = 2))
edges <- igraph::edges(as.vector(ed), arrow.mode=0)
g <- g + edges
# Check whether there is still an indirect connection once direct evidence studies are removed
if (as.logical(is.finite(igraph::shortest.paths(igraph::as.undirected(g),
comparisons[i,1], comparisons[i,2]))) == TRUE) {
# Check if dropping 2-arm studies with both treatments and then either arm from multi-arm
#would lead to disconnected network
check <- check.incon.drops(data, comp=c(as.numeric(comparisons[i,1]),
as.numeric(comparisons[i,2])))
if (!is.null(check)) {
# Identify the path made by the indirect evidence
path <- as.numeric(igraph::shortest_paths(igraph::as.undirected(g),
comparisons[i,1], comparisons[i,2],
weights=NA
)[["vpath"]][[1]])
loop <- sort(path)
splits1 <- append(splits1, comparisons[["t1"]][i])
splits2 <- append(splits2, comparisons[["t2"]][i])
paths <- append(paths, paste(path, collapse="->"))
loops <- append(loops, paste(loop, collapse="->"))
}
}
}
splits <- data.frame("t1"=splits1, "t2"=splits2, "path"=paths, "loops"=loops)
# Ensures only one comparison given per inconsistent loop
splits <- splits[seq(dim(splits)[1],1),]
splits <- splits[duplicated(splits[["loops"]])==FALSE, 1:3]
if (nrow(splits)==0 | (nrow(splits)==1 & any(is.na(splits$t1)))) {
stop("No closed loops of treatments arising from independent sources of evidence are present in the data - testing for consistency is not possible in this network")
}
return(splits)
}
inconsistency.loops(network$data.ab)
?txtProgressBar
inconsistency.loops <- function(data)
{
# Assert checks
checkmate::assertDataFrame(data)
treatments <- factor(unique(data$treatment))
data <- data %>%
dplyr::group_by(studyID) %>%
dplyr::mutate(design=list(as.numeric(treatment)))
comparisons <- ref.comparisons(data)
splits1 <- vector()
splits2 <- vector()
paths <- vector()
loops <- vector()
pb <- txtProgressBar(0, nrow(comparisons), style = 3)
for (i in 1:nrow(comparisons)) {
setTxtProgressBar(pb, i)
drops <- comparisons[-i,]
# Alternative graph create (non-gemtc)
g <- igraph::graph.empty()
g <- g + igraph::vertex(levels(treatments))
#g <- g + igraph::edges.create(new.comparisons, arrow.mode=0)
ed <- t(matrix(c(drops[["t1"]], drops[["t2"]]), ncol = 2))
edges <- igraph::edges(as.vector(ed), arrow.mode=0)
g <- g + edges
# Check whether there is still an indirect connection once direct evidence studies are removed
if (as.logical(is.finite(igraph::shortest.paths(igraph::as.undirected(g),
comparisons[i,1], comparisons[i,2]))) == TRUE) {
# Check if dropping 2-arm studies with both treatments and then either arm from multi-arm
#would lead to disconnected network
check <- check.incon.drops(data, comp=c(as.numeric(comparisons[i,1]),
as.numeric(comparisons[i,2])))
if (!is.null(check)) {
# Identify the path made by the indirect evidence
path <- as.numeric(igraph::shortest_paths(igraph::as.undirected(g),
comparisons[i,1], comparisons[i,2],
weights=NA
)[["vpath"]][[1]])
loop <- sort(path)
splits1 <- append(splits1, comparisons[["t1"]][i])
splits2 <- append(splits2, comparisons[["t2"]][i])
paths <- append(paths, paste(path, collapse="->"))
loops <- append(loops, paste(loop, collapse="->"))
}
}
}
splits <- data.frame("t1"=splits1, "t2"=splits2, "path"=paths, "loops"=loops)
# Ensures only one comparison given per inconsistent loop
splits <- splits[seq(dim(splits)[1],1),]
splits <- splits[duplicated(splits[["loops"]])==FALSE, 1:3]
if (nrow(splits)==0 | (nrow(splits)==1 & any(is.na(splits$t1)))) {
stop("No closed loops of treatments arising from independent sources of evidence are present in the data - testing for consistency is not possible in this network")
}
return(splits)
}
inconsistency.loops(network$data.ab)
inconsistency.loops <- function(data)
{
# Assert checks
checkmate::assertDataFrame(data)
treatments <- factor(unique(data$treatment))
data <- data %>%
dplyr::group_by(studyID) %>%
dplyr::mutate(design=list(as.numeric(treatment)))
comparisons <- ref.comparisons(data)
splits1 <- vector()
splits2 <- vector()
paths <- vector()
loops <- vector()
pb <- txtProgressBar(0, nrow(comparisons), style = 3)
for (i in 1:nrow(comparisons)) {
setTxtProgressBar(pb, i)
drops <- comparisons[-i,]
# Alternative graph create (non-gemtc)
g <- igraph::graph.empty()
g <- g + igraph::vertex(levels(treatments))
#g <- g + igraph::edges.create(new.comparisons, arrow.mode=0)
ed <- t(matrix(c(drops[["t1"]], drops[["t2"]]), ncol = 2))
edges <- igraph::edges(as.vector(ed), arrow.mode=0)
g <- g + edges
# Check whether there is still an indirect connection once direct evidence studies are removed
if (as.logical(is.finite(igraph::shortest.paths(igraph::as.undirected(g),
comparisons[i,1], comparisons[i,2]))) == TRUE) {
# Check if dropping 2-arm studies with both treatments and then either arm from multi-arm
#would lead to disconnected network
check <- suppressMessages(suppressWarnings(
check.incon.drops(data, comp=c(as.numeric(comparisons[i,1]),
as.numeric(comparisons[i,2])))
))
if (!is.null(check)) {
# Identify the path made by the indirect evidence
path <- as.numeric(igraph::shortest_paths(igraph::as.undirected(g),
comparisons[i,1], comparisons[i,2],
weights=NA
)[["vpath"]][[1]])
loop <- sort(path)
splits1 <- append(splits1, comparisons[["t1"]][i])
splits2 <- append(splits2, comparisons[["t2"]][i])
paths <- append(paths, paste(path, collapse="->"))
loops <- append(loops, paste(loop, collapse="->"))
}
}
}
splits <- data.frame("t1"=splits1, "t2"=splits2, "path"=paths, "loops"=loops)
# Ensures only one comparison given per inconsistent loop
splits <- splits[seq(dim(splits)[1],1),]
splits <- splits[duplicated(splits[["loops"]])==FALSE, 1:3]
if (nrow(splits)==0 | (nrow(splits)==1 & any(is.na(splits$t1)))) {
stop("No closed loops of treatments arising from independent sources of evidence are present in the data - testing for consistency is not possible in this network")
}
return(splits)
}
inconsistency.loops(network$data.ab)
nodesplit.result$`20v19`$density.plot
class(nodesplit.result)
class(nodesplit.result) <- "MBNMA.nodesplit"
plot(nodesplit.result, plot.type = "density")
network <- MBNMA.network(HF2PPITT)
inconsistency.loops(network$data.ab)
invisible(inconsistency.loops(network$data.ab))
g
plot(g)
invisible(plot(g))
?invisible
test <- invisible(plot(g))
test
#' Drop treatments from multi-arm (>2) studies for node-splitting
#'
#' Drops arms in a way which preserves connectivity and equally removes
#' data from each treatment in a nodesplit comparison (so as to maximise precision)
drop.comp <- function(ind.df, drops, comp, start=rbinom(1,1,0.5)) {
index <- start
#print(index)
for (i in seq_along(drops)) {
#index <- rbinom(1,1,0.5)
#print(index)
switchloop <- FALSE
temp.df <- ind.df[!(ind.df$studyID %in% drops[i] &
ind.df$treatment==comp[index+1]),]
temp.net <- suppressMessages(plot(MBNMA.network(temp.df), doseparam = 1000))
connectcheck <- is.finite(igraph::shortest.paths(igraph::as.undirected(temp.net),
to=comp[index+1])[
c(comp[1], comp[2])
])
if (!(comp[index+1] %in% temp.df$treatment[!(temp.df$studyID %in% drops[i])] &
all(connectcheck==TRUE))) {
index <- !index
temp.df <- ind.df[!(ind.df$studyID %in% drops[i] &
ind.df$treatment==comp[index+1]),]
}
ind.df <- temp.df
index <- !index
}
return(ind.df)
}
#' Ensures indirect evidence can be estimated for comparisons identified
#' within inconsistency.loops
check.indirect.drops <- function(data=data, comp) {
# Drop studies/comparisons that compare comps
dropID <- vector()
dropcomp <- vector()
studies <- unique(data$studyID)
for (study in seq_along(studies)) {
subset <- data[data$studyID==studies[study],]
if (all(comp %in% subset$treatment)) {
if (subset$narm[1]<=2) {
dropID <- append(dropID, subset$studyID[1])
} else if (subset$narm[1]>2) {
dropcomp <- append(dropcomp, subset$studyID[1])
}
}
}
# Drop studies
data <- data[!(data$studyID %in% dropID),]
# Drop comparisons from studies
stoploop <- FALSE
count <- 1
while(stoploop==FALSE) {
temp <- drop.comp(data, drops=dropcomp, comp=comp)
temp.net <- MBNMA.network(temp)
nt <- length(temp.net$treatments)
if (nt==length(nma.net$treatments)) {
g <- plot(temp.net, doseparam=1000)
connectcheck <- is.finite(igraph::shortest.paths(igraph::as.undirected(g),
to=1)[
c(comp[1], comp[2])
])
if (all(connectcheck==TRUE)) {
data <- temp
stoploop <- TRUE
}
}
#print("Restarting drop.comp")
count <- count+1
if (count==5) {
break()
}
}
if (count<5) {
return(data)
} else {
return(NULL)
}
}
inconsistency.loops(network$data.ab)
check.indirect.drops <- function(data=data, comp) {
# Drop studies/comparisons that compare comps
dropID <- vector()
dropcomp <- vector()
studies <- unique(data$studyID)
for (study in seq_along(studies)) {
subset <- data[data$studyID==studies[study],]
if (all(comp %in% subset$treatment)) {
if (subset$narm[1]<=2) {
dropID <- append(dropID, subset$studyID[1])
} else if (subset$narm[1]>2) {
dropcomp <- append(dropcomp, subset$studyID[1])
}
}
}
# Drop studies
data <- data[!(data$studyID %in% dropID),]
# Drop comparisons from studies
stoploop <- FALSE
count <- 1
while(stoploop==FALSE) {
temp <- drop.comp(data, drops=dropcomp, comp=comp)
temp.net <- MBNMA.network(temp)
nt <- length(temp.net$treatments)
if (nt==length(nma.net$treatments)) {
g <- plot(temp.net, doseparam=1000)
connectcheck <- is.finite(igraph::shortest.paths(igraph::as.undirected(g),
to=1)[
c(comp[1], comp[2])
])
if (all(connectcheck==TRUE)) {
data <- temp
stoploop <- TRUE
}
}
#print("Restarting drop.comp")
count <- count+1
if (count==5) {
break()
}
}
if (count<5) {
return(data)
} else {
return(NULL)
}
}
devtools::load_all(".")
inconsistency.loops(network$data.ab)
devtools::load_all(".")
network <- MBNMA.network(HF2PPITT)
inconsistency.loops(network$data.ab)
devtools::load_all(".")
inconsistency.loops(network$data.ab)
devtools::load_all(".")
inconsistency.loops(network$data.ab)
network <- MBNMA.network(HF2PPITT)
split <- MBNMA.nodesplit(network, likelihood = "binomial", link="logit",
method="common")
plot(split, plot.type = "density")
plot(split, plot.type = NULL)
devtools::load_all(".")
plot(split, plot.type = NULL)
plot(split, plot.type = "density")
plot(split, plot.type = "forest")
noplac.df <- network$data.ab[network$data.ab$narm>2 & network$data.ab$agent!=1,]
net.noplac <- MBNMA.network(noplac.df)
split <- MBNMA.nodesplit(net.noplac, likelihood = "binomial", link="logit",
method="random", drop.discon=TRUE)
devtools::load_all(".")
split <- MBNMA.nodesplit(net.noplac, likelihood = "binomial", link="logit",
method="random", drop.discon=TRUE)
plot(split)
testthat::context("Testing inconsistency.functions")
### Datasets ####
network <- MBNMA.network(HF2PPITT)
# Generate data without placebo
noplac.df <- network$data.ab[network$data.ab$narm>2 & network$data.ab$agent!=1,]
net.noplac <- MBNMA.network(noplac.df)
testthat::test_that("test.inconsistency.loops", {
expect_equal(nrow(inconsistency.loops(network$data.ab)), 4)
expect_equal(nrow(inconsistency.loops(net.noplac$data.ab)), 8) # more loops since ref treatment has changed
incon <- inconsistency.loops(network$data.ab)
expect_identical(names(incon), c("t1", "t2", "path"))
})
network
plot(network)
length(network$treatments)
names(HF2PPITT)
load("~/MBNMA/Datasets/Pfizer Gout Dataset/SUACFB.RData")
names(SUACFB)
load("~/MBNMA/Datasets/Pfizer Gout Dataset/GoutSUA_Abs.RData")
GoutSUA_Abs
hist(time)
hist(GoutSUA_Abs$time)
data.ab <- GoutSUA_Abs
length(unique(data.ab$studyID[data.ab$time==1]))
unique(data.ab$time)
times <- unique(data.ab$time)
for (i in seq_along(times)) {
length(unique(data.ab$studyID[data.ab$time==times[i]]))
}
times <- unique(data.ab$time)
for (i in seq_along(times)) {
print(length(unique(data.ab$studyID[data.ab$time==times[i]])))
}
data.ab[data.ab$time==2,]
data.ab <- data.ab[data.ab$time==2,]
strsplit(data.ab$treatment, split="_")
lapply(data.ab$treatment, function(x) {strsplit(x, split="_")[[1]]})
lapply(data.ab$treatment, function(x) {strsplit(x, split="_")[[1]]})
lapply(data.ab$treatment, function(x) {strsplit(x, split="_")[[1]][1]})
data.ab$agent <- unlist(lapply(data.ab$treatment, function(x) {strsplit(x, split="_")[[1]][1]}))
data.ab$dose <- unlist(lapply(data.ab$treatment, function(x) {strsplit(x, split="_")[[1]][2]}))
data.ba
data.ab
data.ab$dose[data.ab$agent=="Placebo"] <- 0
goutnet <- MBNMA.network(data.ab)
goutnet
plot(goutnet)
plot(goutnet, level="agent")
plot(goutnet)
data.ab
data.ab <- data.ab[data.ab$agent!="RDEA594",]
data.ab <- data.ab[data.ab$agent!="RDEA594",]
goutnet <- MBNMA.network(data.ab)
plot(goutnet, level="agent")
linear <- MBNMA.linear(goutnet)
lienar
linear
nrow(data.ab)
exponential <- MBNMA.exponential(goutnet)
exponential
plot(exponential)
plot(linear)
network
netgout
goutnet
plot(goutnet)
load("~/MBNMA/Datasets/Pfizer Gout Dataset/GoutSUA_Abs.RData")
data.ab <- GoutSUA_Abs
times <- unique(data.ab$time)
for (i in seq_along(times)) {
print(length(unique(data.ab$studyID[data.ab$time==times[i]])))
}
data.ab <- data.ab %>%
dplyr::group_by(studyID, treatment) %>%
dplyr::mutate(fupcount = sequence(n()))
data.ab <- data.ab %>%
dplyr::group_by(studyID, treatment) %>%
dplyr::mutate(fups = n())
data.a
data.ab
load("~/MBNMA/Datasets/Pfizer Gout Dataset/GoutSUA_CFB.RData")
data.ab <- GoutSUA_CFB
data.ab
data.ab <- data.ab %>%
dplyr::group_by(studyID, treatment) %>%
dplyr::mutate(fupcount = sequence(n()))
data.ab <- data.ab %>%
dplyr::group_by(studyID, treatment) %>%
dplyr::mutate(fups = n())
data.ab
library(ggplot2)
ggplot(data.ab, aes(x=time, y=y), group_by=paste0(studyID, "_", treatment)) +
geom_line()
ggplot(data.ab, aes(x=time, y=y), colour=factor(paste0(studyID, "_", treatment))) +
geom_line()
ggplot(data.ab, aes(x=time, y=y, colour=factor(paste0(studyID, "_", treatment)))) +
geom_line()
ggplot(data.ab, aes(x=time, y=y, group_by=factor(paste0(studyID, "_", treatment)))) +
geom_line()
ggplot(data.ab, aes(x=time, y=y), group=factor(paste0(studyID, "_", treatment))) +
geom_line()
ggplot(data.ab, aes(x=time, y=y), group=factor(paste0(studyID, "_", treatment))) +
geom_point()
ggplot(data.ab, aes(x=time, y=y), group=factor(paste0(studyID, "_", treatment))) +
geom_line()
data.ab$groupvar <- factor(paste0(studyID, "_", treatment))
data.ab
data.ab$groupvar <- factor(paste0(data.ab$studyID, "_", data.ab$treatment))
data.ab
ggplot(data.ab, aes(x=time, y=y), group=groupvar) +
geom_line()
ggplot(data.ab, aes(x=time, y=y), group=factor(groupvar)) +
geom_line()
data.ab <- data.ab %>%
dplyr::group_by(studyID, treatment) %>%
dplyr::mutate(latest = ifelse(fups==fupcount, 1, 0))
data.ab
data.ab$latest
data.ab[data.ab$latest==1,]
latest <- data.ab[data.ab$latest==1,]
test <- MBNMA.network(latest)
data.ab <- data.ab[data.ab$latest==1,]
data.ab$agent <- unlist(lapply(data.ab$treatment, function(x) {strsplit(x, split="_")[[1]][1]}))
data.ab$dose <- unlist(lapply(data.ab$treatment, function(x) {strsplit(x, split="_")[[1]][2]}))
data.ab$dose[data.ab$agent=="Placebo"] <- 0
goutnet <- MBNMA.network(data.ab)
data.ab$agent <- unlist(lapply(data.ab$treatment, function(x) {strsplit(x, split="_")[[1]][1]}))
data.ab
data.ab$treatment <- as.character(data.ab$treatment)
data.ab$agent <- unlist(lapply(data.ab$treatment, function(x) {strsplit(x, split="_")[[1]][1]}))
data.ab$dose <- unlist(lapply(data.ab$treatment, function(x) {strsplit(x, split="_")[[1]][2]}))
data.ab$dose[data.ab$agent=="Placebo"] <- 0
goutnet <- MBNMA.network(data.ab)
data.ab$dose <- unlist(lapply(data.ab$treatment, function(x) {strsplit(x, split="_")[[1]][2]}))
data.ab
data.ab$dose
data.ab$dose <- as.numeric(data.ab$dose)
data.ab$dose[data.ab$agent=="Placebo"] <- 0
data.ab$dose
goutnet <- MBNMA.network(data.ab)
data.ab$dose[is.na(data.ab$dose)] <- 0
goutnet <- MBNMA.network(data.ab)
plot(goutnet)
exponential <- MBNMA.exponential(goutnet)
exponential
goutnet
data.ab <- GoutSUA_CFB
times <- unique(data.ab$time)
for (i in seq_along(times)) {
print(length(unique(data.ab$studyID[data.ab$time==times[i]])))
}
data.ab <- data.ab %>%
dplyr::group_by(studyID, treatment) %>%
dplyr::mutate(fupcount = sequence(n()))
data.ab <- data.ab %>%
dplyr::group_by(studyID, treatment) %>%
dplyr::mutate(fups = n())
data.ab <- data.ab %>%
dplyr::group_by(studyID, treatment) %>%
dplyr::mutate(latest = ifelse(fups==fupcount, 1, 0))
data.ab <- data.ab[data.ab$time==2,]
data.ab
View(data.ab)
emax <- MBNMA.exponential(goutnet)
emax <- MBNMA.emax(goutnet)
emax
emax <- MBNMA.emax(goutnet, method="random", n.thin=10000)
emax <- MBNMA.emax(goutnet, method="random", n.iter=10000)
emax
plot(emax)
emax <- MBNMA.emax(goutnet, method="common", n.iter=10000)
emax
goutnet
plot(goutnet, level="agent")
emax <- MBNMA.emax(goutnet, method="common", ed50="common", n.iter=10000)
emax
plot(emax)
emax <- MBNMA.emax(goutnet, method="common", ed50="random", n.iter=10000)
emax
exponential
nrow(goutnet$data.ab)
nrow(network$data.ab)
