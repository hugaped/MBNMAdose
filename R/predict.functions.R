# Functions for predicting responses in MBNMAdose
# Author: Hugo Pedder
# Date created: 2019-04-25



#' Predict responses over time in a given population based on MBNMA time-course
#' models
#'
#' Used to predict responses over time for different treatments or to predict
#' the results of a new study. For MBNMA models that include consistency
#' relative effects on time-course parameters, this is calculated by combining
#' relative treatment effects with a given reference treatment response
#' (specific to the population of interest).
#'
#' Currently does not work with more complex time-course functions (piecelinear,
#' fract.poly.first, fract.poly.second)
#'
#' @param mbnma An S3 object of class `"MBNMA"` generated by running
#'   a time-course MBNMA model
#' @param max.doses A list of numbers. Each element in the list correponds to a
#'   particular agent (named correspondingly to the codes for agents given in `mbnma`)
#'   and each number corresponds to the maximum dose of the given agent, below which a number
#'   of predictions will be calculated for different doses (the number is determined by `n.doses`).
#'   Can only take positive values. If left as `NULL` results will be predicted based on the
#'   maximum dose of each agent given in the data.
#' @param exact.doses A list of numeric vectors. Each element in the list correponds to a
#'   particular agent (named correspondingly to the codes for agents given in `mbnma`)
#'   and each numeric vector corresponds to the
#'   doses of the given agent for which to predict responses. Doses can only take positive
#'   values.
#' @param n.dose A number indicating the number of doses at which to make predictions
#'   within each agent.
#' @param E0.data A value to use for the response at dose = 0 (i.e. placebo) in the prediction.
#'   This is not estimated separately by the model but can be supplied as data, either
#'   as a deterministic value, specified by giving a single number, or a
#'   stochastic distribution, specified by giving a character object that represents a
#'   random number generator (RNG). This can take any RNG distribution for which a
#'   function exists in R in which `n` is replaced with `nsims`. For
#'   example: `"rnorm(nsims, 7, 0.5)"`. Note that the value provided must be on the
#'   natural scale - so for binomial data, proportions should be provided and for Poisson
#'   data, a rate should be provided.
#' @param E0.estimate A data frame containing data to be meta-analysed to estimate
#'   the dose = 0 (placebo) response. This could be an observational
#'   study/studies that are specific to the population on which to make
#'   predictions, or can be a subset of the study arms within the MBNMA dataset
#'   that investigate placebo.
#' @param synth A character object that can take the value `"fixed"` or `"random"` that
#'   specifies the the type of pooling to use for synthesis of `ref.estimate`. Using `"random"` rather
#'   than `"fixed"` for `synth` will result in wider 95\\% CrI for predictions.
#' @param ... Arguments to be sent to R2jags for synthesis of the network
#'   reference treatment effect (using `ref.synth()`)
#'
#'
#' @return An S3 object of class `MBNMA.predict` that contains the following
#'   elements:
#'   * `summary` A named list of data frames. Each data frame contains
#'   a summary of predicted responses at follow-up times specified in `times`
#'   for each treatment specified in `treats`
#'   * `pred.mat` A named list of
#'   matrices. Each matrix contains the MCMC results of predicted responses at
#'   follow-up times specified in `times` for each treatment specified in
#'   `treats`
#'
#' @details `ref.estimate` or `ref.data` only need to be specified if `mbnma` has
#'   been estimated using consistency relative effects (`rel.common` or `rel.random`) for
#'   any time-course parameters, as these inform the absolute values of the
#'   network reference treatment parameters which can then be added to the
#'   relative effects to calculate specific predictions. In this case, only one
#'   or other of `ref.estimate` and `ref.data` should be specified.
#'
#' @examples
#' @export
predict.MBNMA <- function(mbnma, max.doses=NULL, exact.doses=NULL, n.doses=15,
                          E0.estimate=NULL, E0.data=NULL, synth="fixed",
                          ...) {
  ######## CHECKS ########

  # Run checks
  argcheck <- checkmate::makeAssertCollection()
  checkmate::assertClass(mbnma, "MBNMA", add=argcheck)
  checkmate::assertList(max.doses, types="numeric", null.ok=TRUE, add=argcheck)
  checkmate::assertList(exact.doses, types="numeric", null.ok=TRUE, add=argcheck)
  checkmate::assertInt(n.doses, lower=1, add=argcheck)
  checkmate::assertDataFrame(E0.estimate, null.ok=TRUE, add=argcheck)
  checkmate::assertList(E0.data, null.ok=TRUE, types=c("character", "numeric"), add=argcheck)
  checkmate::assertChoice(synth, choices=c("random", "fixed"), add=argcheck)
  checkmate::reportAssertions(argcheck)

  agents <- mbnma$model$data()$agent

  # Checks for doses
  doses <- NULL
  if (!is.null(exact.doses) & !is.null(max.doses)) {
    warning("`exact.dose` and `max.doses` have both been specified in the arguments, yet only one of these can be used. Deferring to using argument given for `exact.doses`")
    max.doses <- NULL
  }
  if (!is.null(exact.doses)) {
    doses <- exact.doses
  } else if (!is.null(max.doses)) {
    doses <- max.doses

    for (i in seq_along(doses)) {
      doses[[i]] <- signif(seq(0,
                               max(doses[[i]]),
                               length.out=n.doses), 2)
    }

  }

  if (!is.null(doses)) {
    if (length(doses)>max(agents, na.rm=TRUE)) {
      stop("A greater number of agents have been supplied in `doses` than are present in the model")
    }
    if (!all(names(doses) %in% c(1:max(agents, na.rm=TRUE)))) {
      stop("Element names in `doses` must correspond to agent codes in `mbnma`")
    }
    for (i in seq_along(doses)) {
      if (!all(doses[[i]]>=0)) {
        stop(paste0("Doses given in `doses` must be positive. Agent ", names(doses)[i], " contains negative values."))
      }
    }
  } else {
    # Automatically generate doses list for treatments included in data
    dose <- as.vector(mbnma$model$data()$dose)
    agent <- as.vector(agents)

    df <- data.frame("agent"=agent, "dose"=dose)
    df <- unique(df[complete.cases(df),])
    df <- dplyr::arrange(df, agent, dose)

    doses <- list()
    for (i in 1:max(df$agent)) {
      doses[[as.character(i)]] <- signif(seq(0,
                                             max(df$dose[df$agent==i]),
                                             length.out=n.doses), 2)
    }
  }

  # Set model arguments
  if (length(mbnma$model.arg$class.effect)>0) {
    stop("`predict.MBNMA currently does not work with models that use class effects")
  }

  link <- mbnma$model.arg$link

  nsims <- mbnma$BUGSoutput$n.keep * mbnma$BUGSoutput$n.chains

  DR <- suppressMessages(
    write.dose.fun(fun=mbnma$model.arg$fun, user.fun=mbnma$model.arg$user.fun,
                   effect="abs"
                   ))
  DR <- gsub("(^.+<-)(.+)", "\\2", DR)

  betaparams <- get.model.vals(mbnma)


  # Identify E0
  if (is.null(E0.data) & is.null(E0.estimate)) {
    stop("E0 cannot be identified - either supply values for `E0.data` or provide a dataset with which to estimate E0 using `E0.estimate`")
  }
  if (!is.null(E0.data) & !is.null(E0.estimate)) {
    stop("Either `E0.data` or `E0.estimate` can be provided, but not both")
  }
  if (!is.null(E0.data)) {
    if (is.numeric(E0.data)) {
      E0 <- E0.data
    } else if (is.character(E0.data)) {
      if (!grepl("^r[a-z]+\\(nsims,.+\\)", E0.data)) {
        stop("Distribution for `E0.data` does not match stochastic random number generator format.\nFormat must take any R random number generator function replacing `n` with `nsims`")
      }
      E0 <- eval(parse(text=E0.data))
    }

    # Convert to scale using link function
    E0 <- rescale.link(E0, direction="link", link=link)

  } else if (!is.null(E0.estimate)) {
    E0 <- ref.synth(data.ab=E0.estimate, mbnma=mbnma, synth=synth)

    if (!("sd.mu" %in% names(E0))) {
      E0 <- E0$m.mu
    } else {
      E0 <- dnorm(E0$m.mu, E0$sd.mu)
    }
  }


  predict.result <- list()

  for (i in seq_along(doses)) {
    predict.result[[names(doses)[i]]] <- list()
    for (k in seq_along(doses[[i]])) {
      if (names(doses)[i]=="1") {
        # Ensures reference agent (placebo) takes E0
        pred <- E0

      } else {
        tempDR <- gsub("\\[agent\\[i,k\\]\\]", "", DR)
        tempDR <- gsub("\\[i,k\\]", "", tempDR)

        dose <- doses[[i]][k]
        for (param in seq_along(betaparams)) {
          if (is.vector(betaparams[[param]]$result)) {
            assign(paste0("s.", names(betaparams)[param]),
                   betaparams[[param]]$result)
          } else if (is.matrix(betaparams[[param]]$result)) {
            assign(paste0("s.", names(betaparams)[param]),
                   betaparams[[param]]$result[,
                                              grepl(
                                                paste0("\\[", as.numeric(names(doses)[i]), "\\]"),
                                                colnames(betaparams[[param]]$result)
                                              )
                                              ]
            )
          }
        }

        pred <- E0 + eval(parse(text=tempDR))
      }

      # Convert to natural scale using link function
      pred <- rescale.link(pred, direction="natural", link=link)

      predict.result[[names(doses)[i]]][[as.character(doses[[i]][k])]] <-
        pred
    }
  }

  output <- list("predicts"=predict.result, "likelihood"=likelihood, "link"=link)

  class(output) <- "MBNMA.predict"

  return(output)
}






#' Get MBNMA model values for dose-response parameters
get.model.vals <- function(mbnma) {

  betaparams <- list()
  for (i in 1:3) {
    beta <- paste0("beta.",i)
    if (!is.null(mbnma$model.arg[[beta]])) {
      temp <- list()
      temp$pool <- mbnma$model.arg[[beta]]

      if (is.null(mbnma$model.arg$arg.params)) {
        temp$name <- betaparams[[beta]]
      } else {
        temp$name <- mbnma$model.arg$arg.params$wrap.params[
          mbnma$model.arg$arg.params$run.params==beta
          ]
      }

      res.mat <- mbnma$BUGSoutput$sims.matrix
      if (temp$pool=="rel") {
        temp$result <- res.mat[,grepl(paste0("^d.", i), colnames(res.mat))]
      } else if (temp$pool=="common") {
        temp$result <- res.mat[,grepl(paste0("^beta.", i), colnames(res.mat))]
      } else if (temp$pool=="random") {
        temp$result <- dnorm(res.mat[,grepl(paste0("^beta.", i), colnames(res.mat))],
                             res.mat[,grepl(paste0("^sd.", i), colnames(res.mat))]
        )
      } else if (is.numeric(temp$pool)) {
        temp$result <- rep(temp$pool, nsims)
      }

      betaparams[[beta]] <- temp
    }
  }

  return(betaparams)

}





#' Synthesise single arm dose = 0 / placebo studies to estimate E0
#'
#' Synthesises single arm studies to estimate E0. Used in predicting responses from a
#' dose-response MBNMA.
#'
#' @inheritParams predict.MBNMA
#' @inheritParams R2jags::jags
#' @param A data frame of arm-level data in "long" format containing the
#'   columns:
#'   * `studyID` Study identifiers
#'   * `y` Numeric data indicating the aggregate response for a continuous outcome. Required for
#'   continuous data.
#'   * `se` Numeric data indicating the standard error for a given observation. Required for
#'   continuous data.
#'   * `r` Numeric data indicating the number of responders within a study arm. Required for
#'   binomial or poisson data.
#'   * `N` Numeric data indicating the total number of participants within a study arm. Required for
#'   binomial data
#'   * `E` Numeric data indicating the total exposure time for participants within a study arm. Required
#'   for poisson data.
#'
#' @details `data.ab` can be a collection of studies that closely resemble the
#'   population of interest intended for the prediction, which could be
#'   different to those used to estimate the MBNMA model, and could include
#'   single arms of RCTs or observational studies. If other data is not
#'   available, the data used to estimate the MBNMA model can be used by
#'   selecting only the studies and arms that investigate dose = 0 (placebo).
#'
#' @return A list of named elements corresponding to E0 and the between-study SD for
#'   E0 if `synth="random"`. Each elemnt contains the full MCMC results from the synthesis.
#'
#' @examples
#' @export
ref.synth <- function(data.ab, mbnma, synth="fixed",
                      n.iter=mbnma$BUGSoutput$n.iter,
                      n.burnin=mbnma$BUGSoutput$n.burnin,
                      n.thin=mbnma$BUGSoutput$n.thin,
                      n.chains=mbnma$BUGSoutput$n.chains,
                      ...) {

  # First need to validate data.frame to check dataset is in correct format...maybe another function for this
  # Change it to correct format if it is not already
  data.ab <- E0.validate(data.ab, likelihood=mbnma$model.arg$likelihood)[["data.ab"]]

  # Run checks
  argcheck <- checkmate::makeAssertCollection()

  checkmate::assertClass(mbnma, "MBNMA", add=argcheck)
  checkmate::assertChoice(synth, choices=c("random", "fixed"), add=argcheck)
  checkmate::assertInt(n.iter, lower=1, add=argcheck)
  checkmate::assertInt(n.burnin, lower=1, add=argcheck)
  checkmate::assertInt(n.thin, lower=1, add=argcheck)
  checkmate::assertInt(n.chains, lower=1, add=argcheck)

  checkmate::reportAssertions(argcheck)

  # To get model for meta-analysis of placebo must create v similar model
  #to study model
  # Do all the MBNMA.write bits but without the consistency bits

  jagsmodel <- write.E0.synth(synth=synth,
                              likelihood=mbnma$model.arg$likelihood,
                              link=mbnma$model.arg$link
  )

  parameters.to.save <- c("m.mu", "resdev", "totresdev")
  if (synth=="random") {
    parameters.to.save <- append(parameters.to.save, "sd.mu")
  }

  jags.result <- suppressWarnings(
    MBNMA.jags(data.ab, model=jagsmodel,
               parameters.to.save=parameters.to.save,
               likelihood=mbnma$model.arg$likelihood,
               link=mbnma$model.arg$link,
               n.iter=n.iter, n.burnin=n.burnin,
               n.thin=n.thin, n.chains=n.chains,
               ...)[["jagsoutput"]]
  )

  result <- list("m.mu"=jags.result$BUGSoutput$sims.list[["m.mu"]])
  if (synth=="random") {
    result[["sd.mu"]] <- jags.result$BUGSoutput$sims.list[["sd.mu"]]
  }

  if (any(jags.result$BUGSoutput$summary[,
                                         colnames(jags.result$BUGSoutput$summary)=="Rhat"
                                         ]>1.02)) {
    warning("Rhat values for parameter(s) in reference treatment synthesis model are >1.02. Suggest running for more iterations.")
  }

  return(result)

}





#' Checks the validity of ref.estimate
#'
#' Ensures `E0.estimate` takes the correct form to allow for synthesis of network
#' reference treatment response
#'
#' @inheritParams ref.synth
E0.validate <- function(data.ab, likelihood=NULL) {

  argcheck <- checkmate::makeAssertCollection()
  checkmate::assertDataFrame(data.ab, any.missing=FALSE, add=argcheck)
  checkmate::assertNames(names(data.ab), must.include = c("studyID"), add=argcheck)
  checkmate::reportAssertions(argcheck)

  if (likelihood=="binomial" & !all(c("r", "N") %in% names(data.ab))) {
    stop("`mbnma` modelled using a binomial likelihood - columns `r` and `N` must be included in `data.ab`")
  } else if (likelihood=="poisson" & !all(c("E", "N") %in% names(data.ab))) {
    stop("`mbnma` modelled using a poisson likelihood - columns `E` and `N` must be included in `data.ab`")
  } else if (likelihood=="normal" & !all(c("y", "se") %in% names(data.ab))) {
    stop("`mbnma` modelled using a normal likelihood - columns `y` and `se` must be included in `data.ab`")
  }

  # Sort data.ab
  data.ab <- dplyr::arrange(data.ab, studyID)

  data.ab <- data.ab %>%
    dplyr::group_by(studyID) %>%
    dplyr::mutate(narm=n())

  if (any(data.ab$narm>1)) {
    stop("Studies in `data.ab` contain >1 arm. ref.synth() only pools single arms.")
  }

  print("Data frame must contain only data from reference treatment")

  #### Prepare data frame ####
  # Add arm index (=1 since only one arm in each study)
  data.ab[["arm"]] <- 1
  data.ab[["narm"]] <- 1

  # Ensuring studies are numbered sequentially
  if (!is.numeric(data.ab[["studyID"]])) {
    print("Studies being recoded to allow sequential numbering")
    data.ab <- transform(data.ab,studyID=as.numeric(factor(studyID, levels=as.character(unique(data.ab$studyID)))))
  } else if (all(abs(diff(data.ab[["studyID"]])) != TRUE)) {
    print("Studies being recoded to allow sequential numbering")
    data.ab <- transform(data.ab,studyID=as.numeric(factor(studyID, levels=as.character(unique(data.ab$studyID)))))
  }
  data.ab <- dplyr::arrange(data.ab, studyID)

  data.ab <- add_index(data.ab)

  return(data.ab)

}




#' Rescale data depending on the link function provided
#'
#' @inheritParams MBNMA.run
#' @param x A numeric vector of data to be rescaled
#' @param direction Can take either `"link"` to convert data to a particular scale
#'   as defined by the `link` function, or `"natural"` to return it to the natural scale.
#'
#' @export
rescale.link <- function(x, direction="link", link="logit") {

  argcheck <- checkmate::makeAssertCollection()
  checkmate::assertNumeric(x, add=argcheck)
  checkmate::assertChoice(direction, choices=c("natural", "link"), null.ok = FALSE, add=argcheck)
  checkmate::assertChoice(link, choices=c("logit", "identity", "log", "probit", "cloglog"), null.ok = FALSE, add=argcheck)
  checkmate::reportAssertions(argcheck)

  if (direction=="link") {
    if (link=="logit") {
      x <- qlogis(x)
    } else if (link=="log") {
      x <- log(x)
    } else if (link=="probit") {
      x <- qnorm(x)
    } else if (link=="cloglog") {
      x <- log(-log(1-x))
    }

  } else if (direction=="natural") {
    if (link=="logit") {
      x <- exp(x) / (1+exp(x))
    } else if (link=="log") {
      x <- exp(x)
    } else if (link=="cloglog") {
      x <- 1-exp(-exp(x))
    } else if (link=="probit") {
      x <- pnorm(x)
    }
  }
  return(x)
}
